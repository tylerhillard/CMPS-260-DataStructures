<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>CMPS 260: Module 13 Class</title>
<style>* { font-family: monospace; }</style>
<script>
//----------------//
// Big O notation //
//----------------//
console.log("Big O notation");

//Linear
function sequentialSearch(array, item){
  var cost = 0;
  for (var i=0; i<array.length; i++){
    cost++;
    if (item === array[i]){ //{1}
      return i;
    }
  }
  console.log('cost for sequentialSearch with an input size ' + array.length + ' is ' + cost);
  return -1;
 }
 
 var arr = [1,2,3,4,5,6,7,8,9,10]; 
 sequentialSearch(arr, -1);

 //Quadratic 

 function bubbleSort(array){
  var length = array.length;
  var cost = 0;
  for (var i=0; i<length; i++){ //{1}
    cost++;
    for (var j=0; j<length-1; j++ ){ //{2}
      cost++;
      if (array[j] > array[j+1]){
        swap(array, j, j+1);
      }
    }
  }
  console.log('cost for bubbleSort with an input size ' + length + ' is ' + cost);
 }
 
 var arr = [1,2,3,4,5]; 
bubbleSort(arr);


// 1. Analyze the complexity of the isPalindrome function below. Make a
//    distinction between best, worst, and average case complexity.

function isPalindrome(str) {
  for (var i = 0; i < str.length/2; i++) {
    if (str[i] !== str[str.length-i-1]) {
      return false;
    }
  }
  return true;
}



/*
Best: O(1)
Worst: O(n)
Average: O(1)  //depends on input
*/

// 2. Write a program that finds the minimum element in a stack in O(1) time
//    complexity. Note that earlier solutions searched through the elements on
//    the stack but that leads to an O(n) solution.
//    NOTE: this question is sometimes asked on interviews.



//----------------------------//
// Having fun with algorithms //
//----------------------------//
console.log("Having fun with algorithms");

// 1. Solve Project Euler problem 1.

// 2. Solve Project Euler problem 2.



//---------//
// Project //
//---------//
console.log("Project");

// 1. The travelling salesman problem is a another classic problem and we are
//    going to solve it using a greedy algorithm. Before starting, please read
//    through the article on Wikipedia:
//      https://en.wikipedia.org/wiki/Travelling_salesman_problem
//    Then implement the following:
//    (a) Create a graph that represents the example symmetric TSP problem on
//        the Wikipedia page.
//    (b) Implement a greedy search that finds the shortest path. You should
//        have the following steps: (1) pick node A as the starting position,
//        (2) pick the closest neighbor that has not been visited as the next
//        city to visit, (3) continue this process until returning to A,
//        (4) print the final length of the path and also the sequence of
//        the cities.
//    (c) Check your results, do they make sense? Is is the optimal solution?



</script>
</head>
<body>
  See console!
</body>
</html>
