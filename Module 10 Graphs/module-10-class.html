<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>CMPS 260: Module 10 Class</title>
<style>* { font-family: monospace; }</style>
<script>
//-------------------//
// Graph terminology //
//-------------------//
console.log("Graph terminology");

// Skip.



//----------------------//
// Representing a graph //
//----------------------//
console.log("Representing a graph");

// Skip.



//--------------------------//
// Creating the Graph class //
//--------------------------//

function Dictionary() {
  // store all elements in the items object
  var items = {};

  this.set = function(key, value) {
    // add a new key-value pair to the dictionary
    items[key] = value;
  };

  this.delete = function(key) {
    // delete a key-value pair
    if (this.has(key)) {
      delete items[key];
      return true;
    }
    return false;
  };

  this.has = function(key) {
    // return true if key is in the dictionary, false otherwise
    return key in items;
  };

  this.get = function(key) {
    // return the value that matches key
    return this.has(key) ? items[key] : undefined;
  };

  this.clear = function() {
    // remove all key-value pairs
    items = {};
  };

  this.size = function() {
    // return the number of key-value pairs
    return Object.keys(items).length;
  };

  this.keys = function() {
    // return an array of all the keys
    return Object.keys(items);
  };

  this.values = function() {
    // return an array of all the values
    var values = [];
    for (var k in items) {
      if (this.has(k)) {
        values.push(items[k]);
      }
    }
    return values;
  };

  this.getItems = function() {
    return items;
  };
}

console.log("Creating the Graph class");

function Graph() {
 var vertices = []; //{1}
 var adjList = new Dictionary(); //{2}


this.addVertex = function(v){
 vertices.push(v); //{3}
 adjList.set(v, []); //{4}
};

this.addEdge = function(v, w){
 adjList.get(v).push(w); //{5}
 adjList.get(w).push(v); //{6}
};

this.toString = function(){
 var s = '';
 for (var i=0; i<vertices.length; i++){ //{10}
 s += vertices[i] + ' -> ';
 var neighbors = adjList.get(vertices[i]); //{11}
 for (var j=0; j<neighbors.length; j++){ //{12}
 s += neighbors[j] + ' ';
 }
 s += '\n'; //{13}
 }
 return s;
};

this.dijkstra = function(src){
 var dist = [], visited = [],
 length = this.graph.length;
 for (var i = 0; i < length; i++) { //{1}
 dist[i] = INF;
 visited[i] = false;
 }
 dist[src] = 0; //{2}
 for (var i = 0; i < length-1; i++){ //{3}
 var u = minDistance(dist, visited); //{4}
 visited[u] = true; //{5}
 for (var v = 0; v < length; v++){
 if (!visited[v] &&
 this.graph[u][v]!=0 && dist[u] != INF &&
 dist[u]+this.graph[u][v] < dist[v]){ //{6}
 dist[v] = dist[u] + this.graph[u][v]; //{7}
 }
 }
 }
 return dist; //{8}
};


}

// 2. Test the Graph class with the example from the book.

var graph = new Graph();
var myVertices = ['A','B','C','D','E','F','G','H','I']; //{7}
for (var i=0; i<myVertices.length; i++){ //{8}
 graph.addVertex(myVertices[i]);
}
graph.addEdge('A', 'B'); //{9}
graph.addEdge('A', 'C');
graph.addEdge('A', 'D');
graph.addEdge('C', 'D');
graph.addEdge('C', 'G');
graph.addEdge('D', 'G');
graph.addEdge('D', 'H');
graph.addEdge('B', 'E');
graph.addEdge('B', 'F');
graph.addEdge('E', 'I');



console.log(graph.toString());

//------------------//
// Graph traversals //
//------------------//
console.log("Graph traversals");

// 1. Implement breadth-first search.



// 2. Implement depth-first search.



//--------------------------//
// Shortest path algorithms //
//--------------------------//
console.log("Shortest path algorithms");

// 1. Implement Dijkstra's algorithm.

var graph = [[0, 2, 4, 0, 0, 0],
 [0, 0, 1, 4, 2, 0],
 [0, 0, 0, 0, 3, 0],
 [0, 0, 0, 0, 0, 2],
 [0, 0, 0, 3, 0, 2],
 [0, 0, 0, 0, 0, 0]];

this.dijkstra = function(src){
 var dist = [], visited = [],
 length = this.graph.length;
 for (var i = 0; i < length; i++) { //{1}
 dist[i] = INF;
 visited[i] = false;
 }
 dist[src] = 0; //{2}
 for (var i = 0; i < length-1; i++){ //{3}
 var u = minDistance(dist, visited); //{4}
 visited[u] = true; //{5}
 for (var v = 0; v < length; v++){
 if (!visited[v] &&
 this.graph[u][v]!=0 && dist[u] != INF &&
 dist[u]+this.graph[u][v] < dist[v]){ //{6}
 dist[v] = dist[u] + this.graph[u][v]; //{7}
 }
 }
 }
 return dist; //{8}
};


// 2. Test your implementation of Dijkstra's algorithm.

var minDistance = function(dist, visited){
 var min = INF, minIndex = -1;
 for (var v = 0; v < dist.length; v++){
 if (visited[v] == false && dist[v] <= min){
 min = dist[v];
 minIndex = v;
 }
 }
 return minIndex;
};

//-----------------------------//
// Minimum spanning tree (MST) //
//-----------------------------//
console.log("Minimum spanning tree (MST)");

// Skip for now (see homework).



//---------//
// Project //
//---------//
console.log("Project");

// 1. Write a function that takes two graphs as input and returns true if
//    they have the same nodes and edges, and false otherwise. Test your code.

function isEqual(graph1, graph2) {
  // ...
}



</script>
</head>
<body>
  See console!
</body>
</html>
